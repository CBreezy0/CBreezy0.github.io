<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transy Baseball Stats 2025</title>
    <style>
        /* (Your CSS styles here - no changes needed) */
        table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 20px;
            font-family: sans-serif;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .error-message {
            color: red;
            font-weight: bold;
        }
    </style>
    <script src="https://apis.google.com/js/api.js"></script>
</head>
<body>
    <h1>Transy Baseball Stats 2025</h1>
     <p>
        <a href="TransylvaniaplayerStatsHitting0.csv" download>Download Hitting Stats</a> |
        <a href="TransylvaniaplayerStatsFielding1.csv" download>Download Fielding Stats</a> |
        <a href="TransylvaniaplayerStatsPitching2.csv" download>Download Pitching Stats</a>
    </p>

    <h2>Hitting Stats</h2>
    <div id="hittingTableContainer"></div>

    <h2>Fielding Stats</h2>
    <div id="fieldingTableContainer"></div>

    <h2>Pitching Stats</h2>
    <div id="pitchingTableContainer"></div>

   <script>
    // Configuration
    const spreadsheetId = '1-Wd8bmHLjyKiwYxqsUNiZVaSty-s0jfTycLMhxsjCy4'; // Replace with YOUR spreadsheet ID
    const CLIENT_ID = 'AIzaSyCqlm4Jo2ZxDogdQIj3jBImW_h_HLj9ujQ'; //REPLACE
    const API_KEY = '555205280925-2b75s565o387o91ritlq66gavafjjqek.apps.googleusercontent.com'; //REPLACE
    const DISCOVERY_DOCS = ["https://sheets.googleapis.com/$discovery/rest?version=v4"];
    const SCOPES = "https://www.googleapis.com/auth/spreadsheets";

    //Initialization, runs when API is loaded
    function initClient() {
        console.log("initClient called"); // LOGGING
        gapi.client.init({
            apiKey: API_KEY,
            clientId: CLIENT_ID,
            discoveryDocs: DISCOVERY_DOCS,
            scope: SCOPES
        }).then(function () {
            console.log("gapi.client.init successful"); // LOGGING

            // Check if user is signed in
            if (gapi.auth2.getAuthInstance().isSignedIn.get()) {
                console.log("User is signed in.");
                loadData();
            } else {
                //Prompts user to sign in and give access
                console.log("User is NOT signed in.  Initiating sign-in..."); // LOGGING
                gapi.auth2.getAuthInstance().signIn().then(
                  function(googleUser) { // Add .then for after sign-in.
                    console.log("Sign-in successful:", googleUser);
                    loadData(); //call load data after sign in
                  },
                  function(error) { // Add error handler.
                    console.error("Sign-in error:", error);
                    alert("Sign-in error: " + error.message); // User-friendly error.
                  }
                );
            }
        }, function(error) {
            console.error("Error initializing client:", error);
            alert('Error initializing client: ' + JSON.stringify(error, null, 2)); //User-friendly error, show details
        });
    }

    //Loads the google api, calls initClient on load
    function handleClientLoad() {
        console.log("handleClientLoad called"); // LOGGING
        gapi.load('client:auth2', initClient);
    }

    async function loadData() {
        //Fetch and upload Hitting
        try{
        const hittingData = await fetchAndParseCSV("TransylvaniaplayerStatsHitting0.csv");
        await updateSheet(spreadsheetId, 'Hitting', combinePlayerData(hittingData));
        } catch (error){
            document.getElementById("hittingTableContainer").innerHTML = `<p class="error-message">Error loading hitting data.</p>`;
            console.error("Hitting Error",error);
        }

        //Fetch and upload Fielding
        try{
        const fieldingData = await fetchAndParseCSV("TransylvaniaplayerStatsFielding1.csv");
        await updateSheet(spreadsheetId, 'Fielding', combinePlayerData(fieldingData));
        } catch(error){
            document.getElementById("fieldingTableContainer").innerHTML = `<p class="error-message">Error loading fielding data.</p>`;
            console.error("Fielding Error", error);
        }

        //Fetch and upload Pitching
        try{
        const pitchingData = await fetchAndParseCSV("TransylvaniaplayerStatsPitching2.csv");
        await updateSheet(spreadsheetId, 'Pitching', combinePlayerData(pitchingData));
        }catch(error){
            document.getElementById("pitchingTableContainer").innerHTML = `<p class="error-message">Error loading pitching data.</p>`;
            console.error("Pitching Error", error);
        }

    }

    async function fetchAndParseCSV(csvFileName) {
        const response = await fetch(csvFileName);
        if (!response.ok) {
            throw new Error(`HTTP error ${response.status}: Could not fetch ${csvFileName}`);
        }
        const csvText = await response.text();
        return parseCSV(csvText);
    }

    function parseCSV(csvText) {
        const lines = csvText.split(/\r\n|\n/);
        const data = [];
        for (const line of lines) {
            if (line.trim() !== "") {
                const values = line.split(',');
                data.push(values);
            }
        }
        return data;
    }

    function combinePlayerData(tableData) {
    const combinedData = [];
    const playerMap = new Map(); // Use a Map to store player data

    // Add the header row
    combinedData.push(tableData[0]);

    // Position abbreviation to full name mapping
    const positionMap = {
        'C': 'Catcher',
        '1B': 'First Base',
        '2B': 'Second Base',
        '3B': 'Third Base',
        'SS': 'Shortstop',
        'OF': 'Outfield',
        'LF': 'Left Field',
        'CF': 'Center Field',
        'RF': 'Right Field',
        'P': 'Pitcher',
        'DH': 'Designated Hitter',
        // Add any other position abbreviations you use
    };


    // Process data rows (skip the header)
    for (let i = 1; i < tableData.length; i++) {
        const row = tableData[i];
        const playerName = row[0]; // Assuming the player's name is in the first column

        if (playerMap.has(playerName)) {
            // Player already exists, combine the data
            const existingRow = playerMap.get(playerName);
            // Find position Column
            let posIndex = tableData[0].indexOf('POS');

            // Concatenate positions *with full names and forward slash*
            const currentPosAbbrev = row[posIndex].trim(); // Get the abbreviation
            const currentPosFull = positionMap[currentPosAbbrev] || currentPosAbbrev; // Get full name, or keep abbreviation if not found

            const existingPosFull = existingRow[posIndex];

              // Check if the position already exists
            if (!existingPosFull.includes(currentPosFull)) {
               existingRow[posIndex] = `${existingPosFull}/${currentPosFull}`;
             }

            // Add up the stats. (Important:  This assumes all other columns are numeric!)
            for (let j = 1; j < row.length; j++) {
                if (!isNaN(parseFloat(row[j])) && j != posIndex ) { // Check if numeric and not POS
                      existingRow[j] = (parseFloat(existingRow[j]) || 0) + (parseFloat(row[j]) || 0); //parse float handles the ''
                }
            }
             playerMap.set(playerName, existingRow);

        } else {
            // New player, add the row to the map *after converting position*
            let posIndex = tableData[0].indexOf('POS');
             const posAbbrev = row[posIndex].trim();
            const posFull = positionMap[posAbbrev] || posAbbrev; // Convert to full name
             row[posIndex] = posFull; //replace abv with full

            playerMap.set(playerName, [...row]); // Create a copy of the row
        }
    }

    // Convert the Map values back to an array
     for (const playerData of playerMap.values()) {
        combinedData.push(playerData);
    }

    return combinedData;
}

  async function updateSheet(spreadsheetId, sheetName, data) {
    if (!data || data.length === 0) {
        console.warn(`No data to write to sheet: ${sheetName}`);
        return;
    }

try {
    //Clear Sheet
    let clearValues = await gapi.client.sheets.spreadsheets.values.clear({
            spreadsheetId: spreadsheetId,
            range: sheetName,
        });
    //Append Data
    let response = await gapi.client.sheets.spreadsheets.values.append({
        spreadsheetId: spreadsheetId,
        range: sheetName,
        valueInputOption: 'USER_ENTERED', // Important: Treat data as if user typed it (for formulas, etc.)
        resource: {
            values: data
        }
    });
    console.log(`${response.result.updates.updatedCells} cells updated in ${sheetName}.`);
  }
  catch(err){
    console.error(`Error updating sheet ${sheetName}:`, err);
    document.getElementById('content').innerText = `Error updating sheet ${sheetName}: ${err.message}`;
  }
}

 //Call handleClientLoad when the page is loaded.
 handleClientLoad();
</script>

</body>
</html>
